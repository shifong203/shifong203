//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//

using HalconDotNet;

public partial class HDevelopExport
{
    // Short Description: 测量顶点
    public void peak(HObject ho_Image, HTuple hv_Row, HTuple hv_Coloumn, HTuple hv_Phi,
        HTuple hv_Length1, HTuple hv_Length2, HTuple hv_DetectWidth, HTuple hv_Sigma,
        HTuple hv_Threshold, HTuple hv_Transition, HTuple hv_Select, out HTuple hv_EdgeRows,
        out HTuple hv_EdgeColumns, out HTuple hv_ResultRow, out HTuple hv_ResultColumn)
    {
        // Local iconic variables

        HObject ho_Rectangle, ho_Regions1;

        // Local control variables

        HTuple hv_ResultCol = null, hv_ROILineRow1 = null;
        HTuple hv_ROILineCol1 = null, hv_ROILineRow2 = null, hv_ROILineCol2 = null;
        HTuple hv_StdLineRow1 = null, hv_StdLineCol1 = null, hv_StdLineRow2 = null;
        HTuple hv_StdLineCol2 = null, hv_Cos = null, hv_Sin = null;
        HTuple hv_Col1 = null, hv_Row1 = null, hv_Col2 = null;
        HTuple hv_Row2 = null, hv_Col3 = null, hv_Row3 = null;
        HTuple hv_Col4 = null, hv_Row4 = null, hv_ResultRows = null;
        HTuple hv_ResultColumns = null, hv_Max = null, hv_i = new HTuple();
        HTuple hv_Distance1 = new HTuple();
        // Initialize local and output iconic variables
        HOperatorSet.GenEmptyObj(out ho_Rectangle);
        HOperatorSet.GenEmptyObj(out ho_Regions1);
        hv_ResultColumn = new HTuple();
        //初始化
        hv_ResultRow = -9999;
        hv_ResultCol = -9999;
        hv_EdgeColumns = new HTuple();
        hv_EdgeRows = new HTuple();

        //仿射矩形Length2所在直线作为rake工具的ROI
        hv_ROILineRow1 = 0;
        hv_ROILineCol1 = 0;
        hv_ROILineRow2 = 0;
        hv_ROILineCol2 = 0;

        //仿射矩形方向所直线的边做基准线
        hv_StdLineRow1 = 0;
        hv_StdLineCol1 = 0;
        hv_StdLineRow2 = 0;
        hv_StdLineCol2 = 0;
        //判断仿射矩形是否有效
        if ((int)((new HTuple(hv_Length1.TupleLessEqual(0))).TupleOr(new HTuple(hv_Length2.TupleLessEqual(
            0)))) != 0)
        {
            ho_Rectangle.Dispose();
            ho_Regions1.Dispose();

            return;
        }

        //计算仿射矩形角度的正弦值、余弦值
        HOperatorSet.TupleCos(hv_Phi, out hv_Cos);
        HOperatorSet.TupleSin(hv_Phi, out hv_Sin);

        //矩形第一个端点坐标
        hv_Col1 = 1.0 * ((hv_Coloumn - (hv_Length1 * hv_Cos)) - (hv_Length2 * hv_Sin));
        hv_Row1 = 1.0 * (hv_Row - (((-hv_Length1) * hv_Sin) + (hv_Length2 * hv_Cos)));

        //矩形第二个端点坐标
        hv_Col2 = 1.0 * ((hv_Coloumn + (hv_Length1 * hv_Cos)) - (hv_Length2 * hv_Sin));
        hv_Row2 = 1.0 * (hv_Row - ((hv_Length1 * hv_Sin) + (hv_Length2 * hv_Cos)));

        //矩形第三个端点坐标
        hv_Col3 = 1.0 * ((hv_Coloumn + (hv_Length1 * hv_Cos)) + (hv_Length2 * hv_Sin));
        hv_Row3 = 1.0 * (hv_Row - ((hv_Length1 * hv_Sin) - (hv_Length2 * hv_Cos)));

        //矩形第四个端点坐标
        hv_Col4 = 1.0 * ((hv_Coloumn - (hv_Length1 * hv_Cos)) + (hv_Length2 * hv_Sin));
        hv_Row4 = 1.0 * (hv_Row - (((-hv_Length1) * hv_Sin) - (hv_Length2 * hv_Cos)));

        //仿射矩形方向所直线的边做基准线
        hv_StdLineRow1 = hv_Row2.Clone();
        hv_StdLineCol1 = hv_Col2.Clone();
        hv_StdLineRow2 = hv_Row3.Clone();
        hv_StdLineCol2 = hv_Col3.Clone();

        //仿射矩形Length2所在直线作为rake工具的ROI
        hv_ROILineRow1 = (hv_Row1 + hv_Row2) * 0.5;
        hv_ROILineCol1 = (hv_Col1 + hv_Col2) * 0.5;
        hv_ROILineRow2 = (hv_Row3 + hv_Row4) * 0.5;
        hv_ROILineCol2 = (hv_Col3 + hv_Col4) * 0.5;
        ho_Rectangle.Dispose();
        HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_Row, hv_Coloumn, hv_Phi,
            hv_Length1, hv_Length2);
        ho_Regions1.Dispose();
        rake(ho_Image, out ho_Regions1, hv_Length2, hv_Length1 * 2, hv_DetectWidth, hv_Sigma,
            hv_Threshold, hv_Transition, hv_Select, hv_ROILineRow1, hv_ROILineCol1, hv_ROILineRow2,
            hv_ROILineCol2, out hv_ResultRows, out hv_ResultColumns);

        //求所有边缘点到基准线的距离，保存最大距离及其对应的边缘点坐标，作为顶点
        hv_Max = 0;
        if ((int)(new HTuple((new HTuple(hv_ResultColumns.TupleLength())).TupleGreater(
            0))) != 0)
        {
            hv_EdgeRows = hv_ResultRows.Clone();
            hv_EdgeColumns = hv_ResultColumns.Clone();
            for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_ResultColumns.TupleLength())) - 1); hv_i = (int)hv_i + 1)
            {
                HOperatorSet.DistancePl(hv_ResultRows.TupleSelect(hv_i), hv_ResultColumns.TupleSelect(
                    hv_i), hv_StdLineRow1, hv_StdLineCol1, hv_StdLineRow2, hv_StdLineCol2,
                    out hv_Distance1);
                if ((int)(new HTuple(hv_Max.TupleLess(hv_Distance1))) != 0)
                {
                    hv_Max = hv_Distance1.Clone();
                    hv_ResultRow = hv_ResultRows.TupleSelect(hv_i);
                    hv_ResultColumn = hv_ResultColumns.TupleSelect(hv_i);
                }
            }
        }

        ho_Rectangle.Dispose();
        ho_Regions1.Dispose();

        return;
    }
}