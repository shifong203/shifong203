//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//

using HalconDotNet;

public partial class HDevelopExport
{
    // Short Description: 测量边缘输出边缘数组点
    public void rake(HObject ho_Image, out HObject ho_Regions, HTuple hv_Elements,
        HTuple hv_DetectHeight, HTuple hv_DetectWidth, HTuple hv_Sigma, HTuple hv_Threshold,
        HTuple hv_Transition, HTuple hv_Select, HTuple hv_Row1, HTuple hv_Column1, HTuple hv_Row2,
        HTuple hv_Column2, out HTuple hv_ResultRow, out HTuple hv_ResultColumn)
    {
        // Stack for temporary objects
        HObject[] OTemp = new HObject[20];

        // Local iconic variables

        HObject ho_RegionLines, ho_Rectangle = null;
        HObject ho_Arrow1 = null, ho_Cross;

        // Local control variables

        HTuple hv_Width = null, hv_Height = null, hv_ATan = null;
        HTuple hv_tRow = null, hv_tCol = null, hv_t = null, hv_i = null;
        HTuple hv_RowC = new HTuple(), hv_ColC = new HTuple();
        HTuple hv_Distance = new HTuple(), hv_RowL2 = new HTuple();
        HTuple hv_RowL1 = new HTuple(), hv_ColL2 = new HTuple();
        HTuple hv_ColL1 = new HTuple(), hv_MsrHandle_Measure = new HTuple();
        HTuple hv_RowEdge = new HTuple(), hv_ColEdge = new HTuple();
        HTuple hv_Amplitude = new HTuple(), hv_Number = new HTuple();
        HTuple hv_j = new HTuple();
        HTuple hv_DetectWidth_COPY_INP_TMP = hv_DetectWidth.Clone();

        // Initialize local and output iconic variables
        HOperatorSet.GenEmptyObj(out ho_Regions);
        HOperatorSet.GenEmptyObj(out ho_RegionLines);
        HOperatorSet.GenEmptyObj(out ho_Rectangle);
        HOperatorSet.GenEmptyObj(out ho_Arrow1);
        HOperatorSet.GenEmptyObj(out ho_Cross);
        //获取图像尺寸
        HOperatorSet.GetImageSize(ho_Image, out hv_Width, out hv_Height);
        //产生一个空显示对象，用于显示
        ho_Regions.Dispose();
        HOperatorSet.GenEmptyObj(out ho_Regions);
        //初始化边缘坐标数组
        hv_ResultRow = new HTuple();
        hv_ResultColumn = new HTuple();
        //产生直线xld
        ho_RegionLines.Dispose();
        HOperatorSet.GenContourPolygonXld(out ho_RegionLines, hv_Row1.TupleConcat(hv_Row2),
            hv_Column1.TupleConcat(hv_Column2));
        //存储到显示对象
        {
            HObject ExpTmpOutVar_0;
            HOperatorSet.ConcatObj(ho_Regions, ho_RegionLines, out ExpTmpOutVar_0);
            ho_Regions.Dispose();
            ho_Regions = ExpTmpOutVar_0;
        }
        //计算直线与x轴的夹角，逆时针方向为正向。
        HOperatorSet.AngleLx(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_ATan);
        //边缘检测方向垂直于检测直线：直线方向正向旋转90°为边缘检测方向
        hv_ATan = hv_ATan + ((new HTuple(90)).TupleRad());
        //临时变量初始化
        //tRow，tCol保存找到指定边缘的坐标
        hv_tRow = 0;
        hv_tCol = 0;
        //t保存边缘的幅度绝对值
        hv_t = 0;
        //根据检测直线按顺序产生测量区域矩形，并存储到显示对象
        HTuple end_val22 = hv_Elements;
        HTuple step_val22 = 1;
        for (hv_i = 1; hv_i.Continue(end_val22, step_val22); hv_i = hv_i.TupleAdd(step_val22))
        {
            //如果只有一个测量矩形，作为卡尺工具，宽度为检测直线的长度
            if ((int)(new HTuple(hv_Elements.TupleEqual(1))) != 0)
            {
                hv_RowC = (1.0 * (hv_Row1 + hv_Row2)) * 0.5;
                hv_ColC = (1.0 * (hv_Column1 + hv_Column2)) * 0.5;
                //判断是否超出图像,超出不检测边缘
                if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                    new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                    hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                {
                    continue;
                }
                HOperatorSet.DistancePp(hv_Row1, hv_Column1, hv_Row2, hv_Column2, out hv_DetectWidth_COPY_INP_TMP);
                //gen_rectangle2_contour_xld (Rectangle, RowC, ColC, ATan, 1.0*DetectHeight/2, 1.0*Distance/2)
            }
            else
            {
                //如果有多个测量矩形，产生该测量矩形xld
                hv_RowC = 1.0 * (hv_Row1 + (((hv_Row2 - hv_Row1) * (hv_i - 1)) / (hv_Elements - 1)));
                hv_ColC = 1.0 * (hv_Column1 + (((hv_Column2 - hv_Column1) * (hv_i - 1)) / (hv_Elements - 1)));
                //判断是否超出图像,超出不检测边缘
                if ((int)((new HTuple((new HTuple((new HTuple(hv_RowC.TupleGreater(hv_Height - 1))).TupleOr(
                    new HTuple(hv_RowC.TupleLess(0))))).TupleOr(new HTuple(hv_ColC.TupleGreater(
                    hv_Width - 1))))).TupleOr(new HTuple(hv_ColC.TupleLess(0)))) != 0)
                {
                    continue;
                }
                ho_Rectangle.Dispose();
                HOperatorSet.GenRectangle2ContourXld(out ho_Rectangle, hv_RowC, hv_ColC,
                    hv_ATan, (1.0 * hv_DetectHeight) / 2, (1.0 * hv_DetectWidth_COPY_INP_TMP) / 2);
            }

            //把测量矩形xld存储到显示对象

            if ((int)(new HTuple(hv_i.TupleEqual(1))) != 0)
            {
                //在第一个测量矩形绘制一个箭头xld，用于只是边缘检测方向
                hv_RowL2 = hv_RowC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                hv_RowL1 = hv_RowC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleSin()));
                hv_ColL2 = hv_ColC + ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                hv_ColL1 = hv_ColC - ((hv_DetectHeight / 2) * (((-hv_ATan)).TupleCos()));
                ho_Arrow1.Dispose();
                gen_arrow_contour_xld(out ho_Arrow1, hv_RowL1, hv_ColL1, hv_RowL2, hv_ColL2,
                    25, 25);
                //把xld存储到显示对象
                {
                    HObject ExpTmpOutVar_0;
                    HOperatorSet.ConcatObj(ho_Regions, ho_Arrow1, out ExpTmpOutVar_0);
                    ho_Regions.Dispose();
                    ho_Regions = ExpTmpOutVar_0;
                }
            }
            //产生测量对象句柄
            HOperatorSet.GenMeasureRectangle2(hv_RowC, hv_ColC, hv_ATan, hv_DetectHeight / 2,
                hv_DetectWidth_COPY_INP_TMP / 2, hv_Width, hv_Height, "bilinear", out hv_MsrHandle_Measure);
            //检测边缘
            HOperatorSet.MeasurePos(ho_Image, hv_MsrHandle_Measure, hv_Sigma, hv_Threshold,
                hv_Transition, hv_Select, out hv_RowEdge, out hv_ColEdge, out hv_Amplitude,
                out hv_Distance);
            //清除测量对象句柄
            HOperatorSet.CloseMeasure(hv_MsrHandle_Measure);
            //找到的边缘必须至少为1个
            HOperatorSet.TupleLength(hv_RowEdge, out hv_Number);
            if ((int)(new HTuple(hv_Number.TupleLess(1))) != 0)
            {
                continue;
            }
            hv_t = 0;
            //有多个边缘时，选择幅度绝对值最大的边缘
            HTuple end_val69 = hv_Number - 1;
            HTuple step_val69 = 1;
            for (hv_j = 0; hv_j.Continue(end_val69, step_val69); hv_j = hv_j.TupleAdd(step_val69))
            {
                if ((int)(new HTuple(((((hv_Amplitude.TupleSelect(hv_j))).TupleAbs())).TupleGreater(
                    hv_t))) != 0)
                {
                    hv_tRow = hv_RowEdge.TupleSelect(hv_j);
                    hv_tCol = hv_ColEdge.TupleSelect(hv_j);
                    hv_t = ((hv_Amplitude.TupleSelect(hv_j))).TupleAbs();
                    continue;
                }
            }
            //把找到的边缘保存在输出数组
            if ((int)(new HTuple(hv_t.TupleGreater(0))) != 0)
            {
                ho_Cross.Dispose();
                HOperatorSet.GenCrossContourXld(out ho_Cross, hv_tRow, hv_tCol, 26, 0);
                hv_ResultRow = hv_ResultRow.TupleConcat(hv_tRow);
                hv_ResultColumn = hv_ResultColumn.TupleConcat(hv_tCol);
            }
        }
        ho_Cross.Dispose();
        HOperatorSet.GenCrossContourXld(out ho_Cross, hv_ResultRow, hv_ResultColumn,
            26, 0);

        ho_RegionLines.Dispose();
        ho_Rectangle.Dispose();
        ho_Arrow1.Dispose();
        ho_Cross.Dispose();

        return;
    }
}