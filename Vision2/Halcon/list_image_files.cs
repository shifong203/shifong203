//
// File generated by HDevelop for HALCON/.NET (C#) Version 17.12
//

using HalconDotNet;

public partial class HDevelopExport
{
    // Chapter: File / Misc
    // Short Description: Get all image files under the given path
    public void list_image_files(HTuple hv_ImageDirectory, HTuple hv_Extensions, HTuple hv_Options,
        out HTuple hv_ImageFiles)
    {
        // Local iconic variables

        // Local control variables

        HTuple hv_ImageDirectoryIndex = null, hv_ImageFilesTmp = new HTuple();
        HTuple hv_CurrentImageDirectory = new HTuple(), hv_HalconImages = new HTuple();
        HTuple hv_OS = new HTuple(), hv_Directories = new HTuple();
        HTuple hv_Index = new HTuple(), hv_Length = new HTuple();
        HTuple hv_NetworkDrive = new HTuple(), hv_Substring = new HTuple();
        HTuple hv_FileExists = new HTuple(), hv_AllFiles = new HTuple();
        HTuple hv_i = new HTuple(), hv_Selection = new HTuple();
        HTuple hv_Extensions_COPY_INP_TMP = hv_Extensions.Clone();

        // Initialize local and output iconic variables
        //This procedure returns all files in a given directory
        //with one of the suffixes specified in Extensions.
        //
        //Input parameters:
        //ImageDirectory: Directory or a tuple of directories with images.
        //   If a local directory is not found, the directory is searched
        //   under %HALCONIMAGES%/ImageDirectory. If %HALCONIMAGES% is not set,
        //   %HALCONROOT%/images is used instead.
        //Extensions: A string tuple containing the extensions to be found
        //   e.g. ['png','tif',jpg'] or others
        //If Extensions is set to 'default' or the empty string '',
        //   all image suffixes supported by HALCON are used.
        //Options: as in the operator list_files, except that the 'files'
        //   option is always used. Note that the 'directories' option
        //   has no effect but increases runtime, because only files are
        //   returned.
        //
        //Output parameter:
        //ImageFiles: A tuple of all found image file names
        //
        if ((int)((new HTuple((new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(new HTuple()))).TupleOr(
            new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(""))))).TupleOr(new HTuple(hv_Extensions_COPY_INP_TMP.TupleEqual(
            "default")))) != 0)
        {
            hv_Extensions_COPY_INP_TMP = new HTuple();
            hv_Extensions_COPY_INP_TMP[0] = "ima";
            hv_Extensions_COPY_INP_TMP[1] = "tif";
            hv_Extensions_COPY_INP_TMP[2] = "tiff";
            hv_Extensions_COPY_INP_TMP[3] = "gif";
            hv_Extensions_COPY_INP_TMP[4] = "bmp";
            hv_Extensions_COPY_INP_TMP[5] = "jpg";
            hv_Extensions_COPY_INP_TMP[6] = "jpeg";
            hv_Extensions_COPY_INP_TMP[7] = "jp2";
            hv_Extensions_COPY_INP_TMP[8] = "jxr";
            hv_Extensions_COPY_INP_TMP[9] = "png";
            hv_Extensions_COPY_INP_TMP[10] = "pcx";
            hv_Extensions_COPY_INP_TMP[11] = "ras";
            hv_Extensions_COPY_INP_TMP[12] = "xwd";
            hv_Extensions_COPY_INP_TMP[13] = "pbm";
            hv_Extensions_COPY_INP_TMP[14] = "pnm";
            hv_Extensions_COPY_INP_TMP[15] = "pgm";
            hv_Extensions_COPY_INP_TMP[16] = "ppm";
            //
        }
        hv_ImageFiles = new HTuple();
        //Loop through all given image directories.
        for (hv_ImageDirectoryIndex = 0; (int)hv_ImageDirectoryIndex <= (int)((new HTuple(hv_ImageDirectory.TupleLength()
            )) - 1); hv_ImageDirectoryIndex = (int)hv_ImageDirectoryIndex + 1)
        {
            hv_ImageFilesTmp = new HTuple();
            hv_CurrentImageDirectory = hv_ImageDirectory.TupleSelect(hv_ImageDirectoryIndex);
            if ((int)(new HTuple(hv_CurrentImageDirectory.TupleEqual(""))) != 0)
            {
                hv_CurrentImageDirectory = ".";
            }
            HOperatorSet.GetSystem("image_dir", out hv_HalconImages);
            HOperatorSet.GetSystem("operating_system", out hv_OS);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(";");
            }
            else
            {
                hv_HalconImages = hv_HalconImages.TupleSplit(":");
            }
            hv_Directories = hv_CurrentImageDirectory.Clone();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_HalconImages.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                hv_Directories = hv_Directories.TupleConcat(((hv_HalconImages.TupleSelect(
                    hv_Index)) + "/") + hv_CurrentImageDirectory);
            }
            HOperatorSet.TupleStrlen(hv_Directories, out hv_Length);
            HOperatorSet.TupleGenConst(new HTuple(hv_Length.TupleLength()), 0, out hv_NetworkDrive);
            if ((int)(new HTuple(((hv_OS.TupleSubstr(0, 2))).TupleEqual("Win"))) != 0)
            {
                for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Length.TupleLength()
                    )) - 1); hv_Index = (int)hv_Index + 1)
                {
                    if ((int)(new HTuple(((((hv_Directories.TupleSelect(hv_Index))).TupleStrlen()
                        )).TupleGreater(1))) != 0)
                    {
                        HOperatorSet.TupleStrFirstN(hv_Directories.TupleSelect(hv_Index), 1,
                            out hv_Substring);
                        if ((int)((new HTuple(hv_Substring.TupleEqual("//"))).TupleOr(new HTuple(hv_Substring.TupleEqual(
                            "\\\\")))) != 0)
                        {
                            if (hv_NetworkDrive == null)
                                hv_NetworkDrive = new HTuple();
                            hv_NetworkDrive[hv_Index] = 1;
                        }
                    }
                }
            }
            hv_ImageFilesTmp = new HTuple();
            for (hv_Index = 0; (int)hv_Index <= (int)((new HTuple(hv_Directories.TupleLength()
                )) - 1); hv_Index = (int)hv_Index + 1)
            {
                HOperatorSet.FileExists(hv_Directories.TupleSelect(hv_Index), out hv_FileExists);
                if ((int)(hv_FileExists) != 0)
                {
                    HOperatorSet.ListFiles(hv_Directories.TupleSelect(hv_Index), (new HTuple("files")).TupleConcat(
                        hv_Options), out hv_AllFiles);
                    hv_ImageFilesTmp = new HTuple();
                    for (hv_i = 0; (int)hv_i <= (int)((new HTuple(hv_Extensions_COPY_INP_TMP.TupleLength()
                        )) - 1); hv_i = (int)hv_i + 1)
                    {
                        HOperatorSet.TupleRegexpSelect(hv_AllFiles, (((".*" + (hv_Extensions_COPY_INP_TMP.TupleSelect(
                            hv_i))) + "$")).TupleConcat("ignore_case"), out hv_Selection);
                        hv_ImageFilesTmp = hv_ImageFilesTmp.TupleConcat(hv_Selection);
                    }
                    HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("\\\\")).TupleConcat(
                        "replace_all"), "/", out hv_ImageFilesTmp);
                    if ((int)(hv_NetworkDrive.TupleSelect(hv_Index)) != 0)
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFilesTmp);
                        hv_ImageFilesTmp = "/" + hv_ImageFilesTmp;
                    }
                    else
                    {
                        HOperatorSet.TupleRegexpReplace(hv_ImageFilesTmp, (new HTuple("//")).TupleConcat(
                            "replace_all"), "/", out hv_ImageFilesTmp);
                    }
                    break;
                }
            }
            //Concatenate the output image paths.
            hv_ImageFiles = hv_ImageFiles.TupleConcat(hv_ImageFilesTmp);
        }

        return;
    }
}